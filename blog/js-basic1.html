<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>基础面试题 (一) | Amelia的前端博客</title>
    <meta name="description" content="我的前端日常日志，学习共勉">
    <meta name="generator" content="VuePress 1.3.0">
    <link rel="icon" href="/logo.jpeg">
    
    <link rel="preload" href="/assets/css/0.styles.7dc41318.css" as="style"><link rel="preload" href="/assets/js/app.647b7f40.js" as="script"><link rel="preload" href="/assets/js/2.dddcbcec.js" as="script"><link rel="preload" href="/assets/js/7.955ba6c0.js" as="script"><link rel="prefetch" href="/assets/js/10.c9edc631.js"><link rel="prefetch" href="/assets/js/3.dc36bf0e.js"><link rel="prefetch" href="/assets/js/4.b0dd307f.js"><link rel="prefetch" href="/assets/js/5.e6948aea.js"><link rel="prefetch" href="/assets/js/6.d24974af.js"><link rel="prefetch" href="/assets/js/8.0e705c0a.js"><link rel="prefetch" href="/assets/js/9.6ea8dc38.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7dc41318.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Amelia的前端博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  阅读
</a></div> <a href="https://amelia-coding.github.io/" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  阅读
</a></div> <a href="https://amelia-coding.github.io/" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/js-basic1.html" class="active sidebar-link">基础面试题 (一)</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="基础面试题-一"><a href="#基础面试题-一" class="header-anchor">#</a> 基础面试题 (一)</h1> <p>🎉 💯</p> <p>JS 基础知识点及常考面试题（一）
JS 对于每位前端开发都是必备技能，在小册中我们也会有多个章节去讲述这部分的知识。首先我们先来熟悉下 JS 的一些常考和容易混乱的基础知识点。</p> <p>原始（Primitive）类型
涉及面试题：原始类型有哪几种？null 是对象嘛？</p> <p>在 JS 中，存在着 6 种原始值，分别是：</p> <p>boolean
null
undefined
number
string
symbol
首先原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString()</p> <p>此时你肯定会有疑问，这不对呀，明明 '1'.toString() 是可以使用的。其实在这种情况下，'1' 已经不是原始类型了，而是被强制转换成了 String 类型也就是对象类型，所以可以调用 toString 函数。</p> <p>除了会在必要的情况下强转类型以外，原始类型还有一些坑。</p> <p>其中 JS 的 number 类型是浮点类型的，在使用中会遇到某些 Bug，比如 0.1 + 0.2 !== 0.3，但是这一块的内容会在进阶部分讲到。string 类型是不可变的，无论你在 string 类型上调用何种方法，都不会对值有改变。</p> <p>另外对于 null 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</p> <p>对象（Object）类型
涉及面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？</p> <p>在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。</p> <p>const a = []
对于常量 a 来说，假设内存地址（指针）为 #001，那么在地址 #001 的位置存放了值 []，常量 a 存放了地址（指针） #001，再看以下代码</p> <p>const a = []
const b = a
b.push(1)
当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 b 存放的地址（指针）也是 #001，当我们进行数据修改的时候，就会修改存放在地址（指针） #001 上的值，也就导致了两个变量的值都发生了改变。</p> <p>接下来我们来看函数参数是对象的情况</p> <p>function test(person) {
person.age = 26
person = {
name: 'yyy',
age: 30
}</p> <p>return person
}
const p1 = {
name: 'yck',
age: 25
}
const p2 = test(p1)
console.log(p1) // -&gt; ?
console.log(p2) // -&gt; ?
对于以上代码，你是否能正确的写出结果呢？接下来让我为你解析一番：</p> <p>首先，函数传参是传递对象指针的副本
到函数内部修改参数的属性这步，我相信大家都知道，当前 p1 的值也被修改了
但是当我们重新为 person 分配了一个对象时就出现了分歧，请看下图</p> <p>所以最后 person 拥有了一个新的地址（指针），也就和 p1 没有任何关系了，导致了最终两个变量的值是不相同的。</p> <p>typeof vs instanceof
涉及面试题：typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？</p> <p>typeof 对于原始类型来说，除了 null 都可以显示正确的类型</p> <p>typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型</p> <p>typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的，在后面的章节中我们也会自己去实现一个 instanceof。</p> <p>const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true</p> <p>var str = 'hello world'
str instanceof String // false</p> <p>var str1 = new String('hello world')
str1 instanceof String // true
对于原始类型来说，你想直接通过 instanceof 来判断类型是不行的，当然我们还是有办法让 instanceof 判断原始类型的</p> <p>class PrimitiveString {
static <a href="x">Symbol.hasInstance</a> {
return typeof x === 'string'
}
}
console.log('hello world' instanceof PrimitiveString) // true
你可能不知道 Symbol.hasInstance 是什么东西，其实就是一个能让我们自定义 instanceof 行为的东西，以上代码等同于 typeof 'hello world' === 'string'，所以结果自然是 true 了。这其实也侧面反映了一个问题， instanceof 也不是百分之百可信的。</p> <p>类型转换
涉及面试题：该知识点常在笔试题中见到，熟悉了转换规则就不惧怕此类题目了。</p> <p>首先我们要知道，在 JS 中类型转换只有三种情况，分别是：</p> <p>转换为布尔值
转换为数字
转换为字符串
我们先来看一个类型转换表格，然后再进入正题</p> <p>转 Boolean
在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。</p> <p>对象转原始类型
对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下：</p> <p>如果已经是原始类型了，那就不需要转换了
调用 x.valueOf()，如果转换为基础类型，就返回转换的值
调用 x.toString()，如果转换为基础类型，就返回转换的值
如果都没有返回原始类型，就会报错
当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。</p> <p>let a = {
valueOf() {
return 0
},
toString() {
return '1'
},
<a href="">Symbol.toPrimitive</a> {
return 2
}
}
1 + a // =&gt; 3
四则运算符
加法运算符不同于其他几个运算符，它有以下几个特点：</p> <p>运算中其中一方为字符串，那么就会把另一方也转换为字符串
如果一方不是字符串或者数字，那么会将它转换为数字或者字符串
1 + '1' // '11'
true + true // 2
4 + [1,2,3] // &quot;41,2,3&quot;
如果你对于答案有疑问的话，请看解析：</p> <p>对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 '11'
对于第二行代码来说，触发特点二，所以将 true 转为数字 1
对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3
另外对于加法还需要注意这个表达式 'a' + + 'b'</p> <p>'a' + + 'b' // -&gt; &quot;aNaN&quot;
因为 + 'b' 等于 NaN，所以结果为 &quot;aNaN&quot;，你可能也会在一些代码中看到过 + '1' 的形式来快速获取 number 类型。</p> <p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</p> <p>4 _ '3' // 12
4 _ [] // 0
4 * [1, 2] // NaN
比较运算符
如果是对象，就通过 toPrimitive 转换对象
如果是字符串，就通过 unicode 字符索引来比较
let a = {
valueOf() {
return 0
},
toString() {
return '1'
}
}
a &gt; -1 // true
在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。</p> <p>this
涉及面试题：如何正确判断 this？箭头函数的 this 是什么？</p> <p>this 是很多人会混淆的概念，但是其实它一点都不难，只是网上很多文章把简单的东西说复杂了。在这一小节中，你一定会彻底明白 this 这个概念的。</p> <p>我们先来看几个函数调用的场景</p> <p>function foo() {
console.log(this.a)
}
var a = 1
foo()</p> <p>const obj = {
a: 2,
foo: foo
}
obj.foo()</p> <p>const c = new foo()
接下来我们一个个分析上面几个场景</p> <p>对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window
对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象
对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this
说完了以上几种情况，其实很多代码中的 this 应该就没什么问题了，下面让我们看看箭头函数中的 this</p> <p>function a() {
return () =&gt; {
return () =&gt; {
console.log(this)
}
}
}
console.log(a()()())
首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind 这类函数是无效的。</p> <p>最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。</p> <p>那么说到 bind，不知道大家是否考虑过，如果对一个函数进行多次 bind，那么上下文会是什么呢？</p> <p>let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // =&gt; ?
如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式</p> <p>// fn.bind().bind(a) 等于
let fn2 = function fn1() {
return function() {
return fn.apply()
}.apply(a)
}
fn2()
可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。</p> <p>let a = { name: 'yck' }
function foo() {
console.log(this.name)
}
foo.bind(a)() // =&gt; 'yck'
以上就是 this 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 this 最终指向哪里。</p> <p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。</p> <p>如果你还是觉得有点绕，那么就看以下的这张流程图吧，图中的流程只针对于单个规则。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.647b7f40.js" defer></script><script src="/assets/js/2.dddcbcec.js" defer></script><script src="/assets/js/7.955ba6c0.js" defer></script>
  </body>
</html>
